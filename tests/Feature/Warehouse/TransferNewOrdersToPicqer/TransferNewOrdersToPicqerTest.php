<?php


namespace Tests\Feature\Warehouse\TransferNewOrdersToPicqer;


use App\SharedKernel\AddressFactory;
use App\User;
use App\Warehouse\Application\TransferNewOrdersToPicqer\TransferNewOrdersToPicqer;
use App\Warehouse\Application\TransferNewOrdersToPicqer\TransferNewOrdersToPicqerInput;
use App\Warehouse\Domain\Orders\Order;
use App\Warehouse\Domain\Orders\OrderedItemFactory;
use App\Warehouse\Domain\Orders\OrderFactory;
use App\Warehouse\Domain\Orders\ProductFactory;
use App\Warehouse\Domain\Repositories\BackorderRepositoryInterface;
use App\Warehouse\Domain\Repositories\PicklistRepositoryInterface;
use App\Warehouse\Domain\Services\OrderProcessorServiceInterface;
use App\Warehouse\Domain\Services\ReviewRequestSenderServiceInterface;
use App\Warehouse\Infrastructure\Persistence\InMemory\Repositories\InMemoryCollectionPicklistRepository;
use App\Warehouse\Infrastructure\Persistence\InMemory\Repositories\InMemoryCollectionShipmentRepository;
use App\Warehouse\Infrastructure\Persistence\InMemory\Repositories\InMemoryOrderRepository;
use App\Warehouse\Infrastructure\Services\WarehouseService;
use App\Woei\Domain\Repositories\ShipmentRepositoryInterface;
use Carbon\CarbonImmutable;
use Carbon\CarbonInterface;
use Illuminate\Foundation\Testing\DatabaseMigrations;
use Illuminate\Support\Collection;
use Laravel\Passport\Passport;
use Tests\Feature\Warehouse\DummyCustomerRepository;
use Tests\Feature\Warehouse\DummyOrderFulfillmentService;
use Tests\Feature\Warehouse\DummyOrderProcessorService;
use Tests\Feature\Warehouse\DummyResourcePlanningService;
use Tests\Feature\Warehouse\DummyReviewRequestSenderService;
use Tests\Feature\Warehouse\InMemoryCollectionBackorderRepository;
use Tests\Feature\Warehouse\TestDomainException;
use Tests\TestCase;
use Tests\Unit\Warehouse\DummyMailerService;

class TransferNewOrdersToPicqerTest extends TestCase
{
    use DatabaseMigrations;

    protected InMemoryOrderRepository $picqerOrderRepository;
    protected InMemoryOrderRepository $sourceOrderRepository;
    protected DummyCustomerRepository $picqerCustomerRepository;
    protected DummyOrderProcessorService $orderProcessor;
    protected DummyResourcePlanningService $resourcePlanningService;
    protected TransferNewOrdersToPicqer $useCase;
    protected TransferNewOrdersToPicqerInput $useCaseInput;
    protected Collection $newOrders;
    protected int $amountOfNewOrders;
    protected WarehouseService $warehouseService;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->picqerOrderRepository = new InMemoryOrderRepository();
        $this->sourceOrderRepository = new InMemoryOrderRepository();
        $this->picqerCustomerRepository = new DummyCustomerRepository();
        $this->orderProcessor = new DummyOrderProcessorService();
        $this->resourcePlanningService = new DummyResourcePlanningService();
        $this->app->bind(ReviewRequestSenderServiceInterface::class, DummyReviewRequestSenderService::class);
        $this->picklistRepository = new InMemoryCollectionPicklistRepository();
        $this->app->bind(PicklistRepositoryInterface::class, function () {return $this->picklistRepository;});
        $this->shipmentRepository = new InMemoryCollectionShipmentRepository();
        $this->app->bind(ShipmentRepositoryInterface::class, function () {return $this->shipmentRepository;});
        $this->backorderRepository = new InMemoryCollectionBackorderRepository();
        $this->app->bind(BackorderRepositoryInterface::class, function () {return $this->backorderRepository;});

        $this->amountOfNewOrders = 10;
        $this->newOrders = OrderFactory::create($this->amountOfNewOrders, [
            'status' => 'new'
        ]);

        $this->sourceOrderRepository->addMultiple($this->newOrders);
        $this->newOrders->each(function (Order $order) {
                $this->picklistRepository->add($order->picklists()->first());
        });

        $this->warehouseService = new WarehouseService($this->picklistRepository, new DummyMailerService(), new DummyReviewRequestSenderService(), $this->picqerCustomerRepository, $this->sourceOrderRepository, new DummyOrderFulfillmentService(), $this->shipmentRepository);
        $this->useCase = new TransferNewOrdersToPicqer($this->sourceOrderRepository, $this->picqerOrderRepository, $this->picqerCustomerRepository, $this->orderProcessor, $this->warehouseService, $this->backorderRepository);
        $this->useCaseInput = new TransferNewOrdersToPicqerInput();
    }

    /** @test */
    public function it_should_add_new_orders_in_picqer()
    {
        // Given
        // See instance variables

        // When
        $this->useCase->execute($this->useCaseInput);

        // Then
        self::assertEquals($this->amountOfNewOrders, $this->picqerOrderRepository->findAll()->count());
    }

    /** @test */
    public function it_should_process_the_new_orders()
    {
        // Given
        // See instance variables

        // When
        $this->useCase->execute($this->useCaseInput);

        // Then
        self::assertEquals($this->amountOfNewOrders, sizeof($this->orderProcessor->processedOrders()));
    }

    /** @test */
    public function it_should_add_new_customer_if_it_does_not_exist()
    {
        // Given
        // See instance variables

        // When
        $this->useCase->execute($this->useCaseInput);

        // Then
        self::assertEquals($this->amountOfNewOrders, sizeof($this->picqerCustomerRepository->all()));
    }

    /** @test */
    public function it_should_only_add_the_order_if_it_does_not_exist()
    {
        // Given
        // See instance variables

        // When
        $this->useCase->execute($this->useCaseInput);
        $this->useCase->execute($this->useCaseInput);

        // Then
        self::assertEquals($this->amountOfNewOrders, $this->picqerOrderRepository->findAll()->count());
    }

    /** @test */
    public function it_should_update_the_customer_information()
    {
        // Given
        $customer = $this->newOrders->first()->customer();
        $this->picqerCustomerRepository->add($customer);
        $newPhoneNumber = "0688888888";
        $newName = "Test Name New";

        $customer->changePhoneNumber($newPhoneNumber);
        $customer->changeName($newName);

        // When
        $this->useCase->execute($this->useCaseInput);

        // Then
        $foundCustomer = $this->picqerCustomerRepository->searchByEmail($customer->email());
        self::assertEquals($customer, $foundCustomer);
    }

    /** @test */
    public function it_should_update_the_invoice_address_on_the_customer()
    {
        // Given
        $customer = $this->newOrders->first()->customer();
        $this->picqerCustomerRepository->add($customer);
        $newInvoiceAddress = AddressFactory::fromStreetAddress("John Doe Street 1", "Delft", "2628DD", "NL");
        $customer->changeInvoiceAddress($newInvoiceAddress);

        // When
        $this->useCase->execute($this->useCaseInput);

        // Then
        self::assertEquals($newInvoiceAddress, $this->picqerCustomerRepository->searchByEmail($customer->email())->invoiceAddress());
    }

    /** @test */
    public function it_should_update_the_delivery_address_on_the_customer()
    {
        // Given
        $customer = $this->newOrders->first()->customer();
        $this->picqerCustomerRepository->add($customer);
        $newDeliveryAddress = AddressFactory::fromStreetAddress("John Doe Street 1", "Delft", "2628DD", "NL");
        $customer->changeDeliveryAddress($newDeliveryAddress);

        // When
        $this->useCase->execute($this->useCaseInput);

        // Then
        self::assertEquals($newDeliveryAddress, $this->picqerCustomerRepository->searchByEmail($customer->email())->deliveryAddress());
    }

    /** @test */
    public function it_should_update_the_address_on_the_customer()
    {
        // Given
        $customer = $this->newOrders->first()->customer();
        $this->picqerCustomerRepository->add($customer);
        $newAddress = AddressFactory::fromStreetAddress("John Doe Street 1", "Delft", "2628DD", "NL");
        $customer->changeAddress($newAddress);

        // When
        $this->useCase->execute($this->useCaseInput);

        // Then
        self::assertEquals($newAddress, $this->picqerCustomerRepository->searchByEmail($customer->email())->address());
    }

    /** @test */
    public function it_should_add_order_to_failed_orders_when_exception_is_thrown_and_update_status_of_order()
    {
        // Given
        $orderProcessorMock = $this->createMock(OrderProcessorServiceInterface::class);
        $orderProcessorMock->method('process')
                            ->willThrowException(new \Exception("Test Exception"));

        $useCase = new TransferNewOrdersToPicqer($this->sourceOrderRepository, $this->picqerOrderRepository, $this->picqerCustomerRepository, $orderProcessorMock, $this->warehouseService, $this->backorderRepository);
        $useCaseInput = new TransferNewOrdersToPicqerInput();

        // When
        $useCaseResult = $useCase->execute($useCaseInput);
        $foundOrders = $this->sourceOrderRepository->findAll();

        // Then
        self::assertEquals($this->amountOfNewOrders, sizeof($useCaseResult->failedOrders()));

        foreach ($foundOrders as $foundOrder)
        {
            self::assertEquals("denied", $foundOrder->status());
        }
    }

    /** @test */
    public function it_should_add_order_to_processed_orders_when_everything_goes_right()
    {
        // Given
        // See instance variables

        // When
        $useCaseResult = $this->useCase->execute($this->useCaseInput);

        // Then
        self::assertEquals($this->newOrders->count(), $useCaseResult->processedOrders()->count());
    }

    /** @test */
    public function it_should_change_status_of_order_when_successfully_transferred() {

        // Given
        // See instance variables

        // When
        $useCaseResult = $this->useCase->execute($this->useCaseInput);

        // Then
        $foundOrders = $this->sourceOrderRepository->findAll();

        foreach ($foundOrders as $foundOrder)
        {
            self::assertEquals("processing", $foundOrder->status());
        }
    }

    /** @test */
    public function it_should_be_able_to_call_the_route() {

        // Given
        Passport::actingAs(User::factory()->create());
        $this->withoutExceptionHandling();

        $url = route('transfer-new-orders-to-picqer');

        // When
        $response = $this->post($url, [
            'from' => 'dummy'
        ]);

        // Then
        $response->assertStatus(200);
    }

    /** @test */
    public function it_should_add_action_with_reason_unknown_when_no_domain_exception_is_thrown()
    {
        // Given
        $orderProcessorMock = $this->createMock(OrderProcessorServiceInterface::class);
        $orderProcessorMock->method('process')
            ->willThrowException(new \Exception("No Domain Exception"));

        $useCase = new TransferNewOrdersToPicqer($this->sourceOrderRepository, $this->picqerOrderRepository, $this->picqerCustomerRepository, $orderProcessorMock, $this->warehouseService, $this->backorderRepository);
        $useCaseInput = new TransferNewOrdersToPicqerInput();

        // When
        $useCaseResult = $useCase->execute($useCaseInput);
        $foundOrders = $this->sourceOrderRepository->findAll();

        // Then
        foreach ($foundOrders as $foundOrder)
        {
            self::assertEquals(1, $foundOrder->actions()->count());
            self::assertEquals("Status gewijzigd van Picqer - In behandeling naar Picqer - Afgewezen - Reden: Onbekend, vraag iemand van IT om hulp", $foundOrder->actions()->first()->description());
            self::assertEquals(CarbonImmutable::now()->format('Y-m-d H:i:s'), $foundOrder->actions()->first()->createdAt()->format('Y-m-d H:i:s'));
            self::assertEquals('Webservices', $foundOrder->actions()->first()->actor());
        }
    }

    /** @test */
    public function it_should_add_actions_with_domain_related_description_when_domain_exception_is_thrown()
    {
        // Given
        $orderProcessorMock = $this->createMock(OrderProcessorServiceInterface::class);
        $orderProcessorMock->method('process')
            ->willThrowException(new TestDomainException("Domein gerelateerde fout"));

        $useCase = new TransferNewOrdersToPicqer($this->sourceOrderRepository, $this->picqerOrderRepository, $this->picqerCustomerRepository, $orderProcessorMock, $this->warehouseService, $this->backorderRepository);
        $useCaseInput = new TransferNewOrdersToPicqerInput();

        // When
        $useCaseResult = $useCase->execute($useCaseInput);
        $foundOrders = $this->sourceOrderRepository->findAll();

        // Then
        foreach ($foundOrders as $foundOrder)
        {
            self::assertEquals(1, $foundOrder->actions()->count());
            self::assertEquals("Status gewijzigd van Picqer - In behandeling naar Picqer - Afgewezen - Reden: Domein gerelateerde fout", $foundOrder->actions()->first()->description());
            self::assertEquals(CarbonImmutable::now()->format('Y-m-d H:i:s'), $foundOrder->actions()->first()->createdAt()->format('Y-m-d H:i:s'));
            self::assertEquals('Webservices', $foundOrder->actions()->first()->actor());
        }
    }

    /** @test */
    public function it_should_not_change_description_of_ordered_item_when_resource_is_equal_to_product()
    {
        // Given
        $order = OrderFactory::create(1, [
            "status" => "new"
        ])->first();
        $productCode = "Test Product Code";
        $productGroup = "Test Product Group";

        $orderedItem =  OrderedItemFactory::orderedItem(null, ProductFactory::productWithProductGroup($productCode, $productGroup), 1);
        $order->changeOrderedItems(array($orderedItem));

        $sourceOrderRepository = new InMemoryOrderRepository();
        $sourceOrderRepository->add($order);
        $useCase = new TransferNewOrdersToPicqer($sourceOrderRepository, $this->picqerOrderRepository, $this->picqerCustomerRepository, $this->orderProcessor, $this->warehouseService, $this->backorderRepository);
        $useCaseInput = new TransferNewOrdersToPicqerInput();

        // When
        $useCase->execute($useCaseInput);

        // Then
        self::assertNull($order->items()[0]->description());
    }

    /** @test */
    public function it_should_change_description_of_ordered_item_when_resource_is_not_equal_to_product()
    {
        // Given
        $order = OrderFactory::create(1, [
            "status" => "new"
        ])->first();
        $productCode = "Test Product Code";
        $productGroup = "Test Product Group";

        $orderedItem =  OrderedItemFactory::orderedItem(null, ProductFactory::productWithProductGroup($productCode, $productGroup), 1);
        $order->changeOrderedItems(array($orderedItem));

        $sourceOrderRepository = new InMemoryOrderRepository();
        $sourceOrderRepository->add($order);
        $useCase = new TransferNewOrdersToPicqer($sourceOrderRepository, $this->picqerOrderRepository, $this->picqerCustomerRepository, $this->orderProcessor, $this->warehouseService, $this->backorderRepository);
        $useCaseInput = new TransferNewOrdersToPicqerInput();

        // When
        $useCase->execute($useCaseInput);

        // Then
        self::assertNull($order->items()[0]->description());
    }

    /** @test */
    public function it_should_snooze_the_picklist_until_saturday_when_preferred_delivery_date_is_monday()
    {
        // We are not snoozing here anymore, but maybe again in the future. Because we do this in HandlePicklistCreated.
        $this->markTestSkipped();
        // Given
        Passport::actingAs(User::factory()->create());
        $preferredDeliveryDate = CarbonImmutable::now()->next(CarbonInterface::MONDAY);
        $order = OrderFactory::create(1, [
            'preferredDeliveryDate' => $preferredDeliveryDate,
            'status' => 'new'
        ])->first();

        $this->sourceOrderRepository->add($order);
        $this->picklistRepository->add($order->picklists()->first());

        // When
        $this->useCase->execute($this->useCaseInput);
        $foundOrder = $this->sourceOrderRepository->findOneByReference($order->reference());

        // Then
        self::assertEquals($preferredDeliveryDate->subDays(2)->toDateString(), $foundOrder->picklists()->first()->snoozedUntil()->toDateString());
    }

    /** @test */
    public function it_should_snooze_the_picklist_until_yesterday_when_preferred_delivery_date_is_wednesday()
    {

        // We are not snoozing here anymore, but maybe again in the future. Because we do this in HandlePicklistCreated.
        $this->markTestSkipped();

        // Given
        Passport::actingAs(User::factory()->create());
        $preferredDeliveryDate = CarbonImmutable::now()->next(CarbonInterface::WEDNESDAY);

        $order = OrderFactory::create(1, [
            'preferredDeliveryDate' => $preferredDeliveryDate,
            'status' => 'new'
        ])->first();

        $this->sourceOrderRepository->add($order);
        $this->picklistRepository->add($order->picklists()->first());

        // When
        $this->useCase->execute($this->useCaseInput);
        $foundOrder = $this->sourceOrderRepository->findOneByReference($order->reference());

        // Then
        self::assertEquals($preferredDeliveryDate->subDays(1)->toDateString(), $foundOrder->picklists()->first()->snoozedUntil()->toDateString());
    }

}
