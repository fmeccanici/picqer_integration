<?php


namespace Tests\Feature\Warehouse;

use App\PostNL\Models\Carrier;
use App\User;
use App\Warehouse\Application\HandleShipmentCreated\HandleShipmentCreatedInput;
use App\Warehouse\Application\HandleShipmentCreated\HandleShipmentCreatedResult;
use App\Warehouse\Domain\DiscountCodes\DiscountCode;
use App\Warehouse\Domain\Employees\Employee;
use App\Warehouse\Domain\Exporters\PackingSlipGeneratorInterface;
use App\Warehouse\Domain\Mails\CouponMail;
use App\Warehouse\Domain\Mails\MailerServiceInterface;
use App\Warehouse\Domain\Mails\TrackAndTraceMail;
use App\Warehouse\Domain\Orders\Order;
use App\Warehouse\Domain\Orders\OrderedItemFactory;
use App\Warehouse\Domain\Orders\OrderFactory;
use App\Warehouse\Domain\Orders\ProductFactory;
use App\Warehouse\Domain\Orders\ShippingDateEstimation;
use App\Warehouse\Domain\Parties\CustomerFactory;
use App\Warehouse\Domain\Repositories\DiscountCodeRepositoryInterface;
use App\Warehouse\Domain\Repositories\EmployeeRepositoryInterface;
use App\Warehouse\Domain\Repositories\ShipmentRepositoryInterface;
use App\Warehouse\Domain\ReviewRequests\ReviewRequest;
use App\Warehouse\Domain\Services\OrderFulfillmentServiceInterface;
use App\Warehouse\Domain\Services\ReviewRequestSenderServiceInterface;
use App\Warehouse\Domain\Shipments\PackingSlip;
use App\Warehouse\Domain\Shipments\ShipmentFactory;
use App\Warehouse\Infrastructure\Jobs\HandleShipmentCreatedJob;
use App\Warehouse\Infrastructure\Persistence\InMemory\Repositories\InMemoryCollectionEmployeeRepository;
use App\Warehouse\Infrastructure\Persistence\InMemory\Repositories\InMemoryCollectionShipmentRepository;
use App\Warehouse\Infrastructure\Persistence\InMemory\Repositories\InMemoryDiscountCodeRepository;
use App\Warehouse\Infrastructure\Persistence\InMemory\Repositories\InMemoryOrderRepository;
use App\Warehouse\Infrastructure\Services\WarehouseService;
use Carbon\CarbonImmutable;
use Illuminate\Foundation\Testing\DatabaseMigrations;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Queue;
use Laravel\Passport\Passport;
use Mockery\MockInterface;
use Tests\TestCase;
use Tests\Unit\Warehouse\DummyMailerService;

class HandleShipmentCreatedTest extends TestCase
{
    use DatabaseMigrations;

    private InMemoryOrderRepository $orderRepository;
    private DummyMailerService $mailerService;
    private \App\PostNL\Classes\Carrier $carrier;
    private DummyPackingSlipGenerator $packingListGenerator;
    private Carrier $carrierModel;
    private $reviewRequestSenderMock;

    /**
     * @var ReviewRequest
     */
    private ReviewRequest $reviewRequest;

    private \App\Warehouse\Domain\Parties\Customer $customer;

    private DummyCustomerRepository|\PHPUnit\Framework\MockObject\MockObject $customerRepositoryMock;
    private InMemoryCollectionShipmentRepository $shipmentRepository;
    protected InMemoryCollectionEmployeeRepository $employeeRepository;
    protected Employee $employee;
    protected DiscountCodeRepositoryInterface $discountCodeRepository;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->orderRepository = new InMemoryOrderRepository();
        $this->mailerService = new DummyMailerService();
        $this->app->bind(MailerServiceInterface::class, function () {return $this->mailerService;});

        $this->app->bind(PackingSlipGeneratorInterface::class, DummyPackingSlipGenerator::class);

        $this->customer = CustomerFactory::constantSameAddresses();
        $this->customerRepositoryMock = $mock = $this->createMock(DummyCustomerRepository::class);
        $mock->method('searchByCustomerNumber')
            ->willReturn($this->customer);

        $this->shipmentRepository = new InMemoryCollectionShipmentRepository();
        $this->app->bind(ShipmentRepositoryInterface::class, function () {return $this->shipmentRepository;});
        $this->app->bind(ReviewRequestSenderServiceInterface::class, DummyReviewRequestSenderService::class);

        $this->user = User::factory()->create();
        Passport::actingAs($this->user);

        $this->employeeRepository = new InMemoryCollectionEmployeeRepository();
        $this->app->bind(EmployeeRepositoryInterface::class, function () {return $this->employeeRepository;});

        $this->discountCodeRepository = new InMemoryDiscountCodeRepository();
        $this->app->bind(DiscountCodeRepositoryInterface::class, function () {return $this->discountCodeRepository;});

        $firstName = explode(" ", $this->user->name)[0];
        $lastName = explode(" ", $this->user->name)[1];
        $this->employee = new Employee($firstName, $lastName);
        $this->employee->setIdentity($this->user->id);
        $this->employeeRepository->save($this->employee);
    }

    /** @test */
    public function it_should_use_the_shipment_as_input()
    {
        // Given
        $orderReference = "123456";
        $shipment = ShipmentFactory::create($orderReference);
        $order = OrderFactory::constantUnprocessedTwoPicklists();
        $order->changeReference($orderReference);
        $reviewRequest = new ReviewRequest($order->reference(), $order->customer()->name(), $order->customer()->email(), $order->preferredDeliveryDate());
        $reviewRequestSenderMock = $this->createMock(DummyReviewRequestSenderService::class);
        $reviewRequestSenderMock->method('send')
            ->willReturn($reviewRequest);

        $input = [
            "shipment" => $shipment->toArray(),
            'send_track_and_trace_mail' => true,
            'send_review_request' => true,
            'agent' => 'delight',
            'packed_by_name' => 'Test Name'
        ];

        // When
        $useCaseInput = new HandleShipmentCreatedInput($input);

        // Then
        self::assertEquals($shipment->toArray(), $useCaseInput->shipment());
    }

    /** @test */
    public function it_should_have_the_sent_emails_and_shipment_as_output()
    {
        // Given
        $order = OrderFactory::constantUnprocessed();
        $customer = $order->customer();
        $shipment = ShipmentFactory::create($order->reference());
        $email = new TrackAndTraceMail($customer, $order, $shipment, new PackingSlip("Test Path", 'test-url'));

        // When
        $useCaseResult = new HandleShipmentCreatedResult(collect(array($email)), $shipment, new ReviewRequest($order->reference(), $order->customer()->name(), $order->customer()->email(), $order->preferredDeliveryDate()));

        // Then
        self::assertEquals($email, $useCaseResult->sentEmails()->first());
        self::assertEquals($shipment, $useCaseResult->shipment());
    }

    /** @test */
    public function it_should_send_a_track_and_trace_email_when_order_is_fully_fulfilled()
    {
        // Given
        $order = OrderFactory::create(1, [
            'status' => 'unprocessed'
        ])->first();
        $this->orderRepository->add($order);
        $shipment = ShipmentFactory::create($order->reference(), [
            'trackAndTraceMailSent' => false
        ]);
        $shipment->changeOrderedItems(collect($order->items()));
        $mailerServiceMock = $this->createMock(DummyMailerService::class);
        $mailerServiceMock->method('isAlreadySent')
            ->willReturn(false);

        $this->app->bind(MailerServiceInterface::class, function () use ($mailerServiceMock) {return $mailerServiceMock;});

        $orderFulfillmentService = $this->mock(OrderFulfillmentServiceInterface::class, function (MockInterface $mock) {
            $mock->shouldReceive('isFulfilled')
                 ->once()
                 ->andReturn(true);
        });

        $reviewRequest = new ReviewRequest($order->reference(), $order->customer()->name(), $order->customer()->email(), $order->preferredDeliveryDate());
        $reviewRequestSenderMock = $this->createMock(DummyReviewRequestSenderService::class);
        $reviewRequestSenderMock->method('send')
            ->willReturn($reviewRequest);

        $warehouseService = new WarehouseService(new DummyPicklistRepository(),
            $mailerServiceMock,
            $reviewRequestSenderMock,
            $this->customerRepositoryMock,
            $this->orderRepository,
            $orderFulfillmentService,
            $this->shipmentRepository,
            $this->discountCodeRepository
        );

        // When
        $handleShipmentCreatedJob = new HandleShipmentCreatedJob($warehouseService, $shipment, $this->user->name);
        $useCaseResult = $handleShipmentCreatedJob->handle();

        // Then
        $shipment = $this->shipmentRepository->findOneByReference($shipment->reference());

        self::assertTrue($shipment->trackAndTraceMailSent());
    }

    /** @test */
    public function it_should_log_and_dont_send_emails_when_order_is_not_found()
    {
        // Given
        $order = OrderFactory::create(1, [
            'status' => 'unprocessed'
        ])->first();

        $shipment = ShipmentFactory::create($order->reference());
        $shipment->changeOrderedItems(collect($order->items()));

        $reviewRequest = new ReviewRequest($order->reference(), $order->customer()->name(), $order->customer()->email(), $order->preferredDeliveryDate());
        $reviewRequestSenderMock = $this->createMock(DummyReviewRequestSenderService::class);
        $reviewRequestSenderMock->method('send')
            ->willReturn($reviewRequest);

        $warehouseService = new WarehouseService(new DummyPicklistRepository(),
            new DummyMailerService(),
            $reviewRequestSenderMock,
            $this->customerRepositoryMock,
            $this->orderRepository,
            new DummyOrderFulfillmentService(),
            $this->shipmentRepository,
            $this->discountCodeRepository);

        $handleShipmentCreatedJob = new HandleShipmentCreatedJob($warehouseService, $shipment, $this->user->name);

        // Assert
        Log::shouldReceive('error')
            ->once()
            ->withArgs(function ($message) use($shipment) {
                return str_contains($message, "Order with reference " . $shipment->orderReference() . " not found");
            });

        // When
        $useCaseResult = $handleShipmentCreatedJob->handle();

        // Then
        self::assertEmpty($useCaseResult->sentEmails());
    }

    /** @test */
    public function it_should_log_when_order_has_empty_ordered_items()
    {
        // Given
        $order = OrderFactory::create(1, [
            'status' => 'unprocessed'
        ])->first();

        $shipment = ShipmentFactory::create($order->reference());
        $shipment->changeOrderedItems(collect($order->items()));

        $order->changeOrderedItems([]);

        $reviewRequest = new ReviewRequest($order->reference(), $order->customer()->name(), $order->customer()->email(), $order->preferredDeliveryDate());
        $reviewRequestSenderMock = $this->createMock(DummyReviewRequestSenderService::class);
        $reviewRequestSenderMock->method('send')
            ->willReturn($reviewRequest);

        $warehouseService = new WarehouseService(new DummyPicklistRepository(),
            new DummyMailerService(),
            $reviewRequestSenderMock,
            $this->customerRepositoryMock,
            $this->orderRepository,
            new DummyOrderFulfillmentService(),
            $this->shipmentRepository,
            $this->discountCodeRepository);


        // When
        $handleShipmentCreatedJob = new HandleShipmentCreatedJob($warehouseService, $shipment, $this->user->name);

        // Assert
        Log::shouldReceive('error')
            ->once()
            ->withArgs(function ($message) use($shipment) {
                return str_contains($message, "Order with reference " . $shipment->orderReference() . " not found");
            });

        // When
        $useCaseResult = $handleShipmentCreatedJob->handle();

        // Then
        self::assertEmpty($useCaseResult->sentEmails());
    }

    /** @test */
    public function it_should_send_a_track_and_trace_email()
    {
        // Given
        $order = OrderFactory::create(1, [
            'status' => 'unprocessed'
        ])->first();
        $this->orderRepository->add($order);

        $shipment = ShipmentFactory::create($order->reference(), [
            'trackAndTraceMailSent' => false
        ]);
        $shipment->changeOrderedItems(collect($order->items()));

        $mailerServiceMock = $this->createMock(DummyMailerService::class);
        $mailerServiceMock->method('isAlreadySent')
            ->willReturn(false);

        $reviewRequest = new ReviewRequest($order->reference(), $order->customer()->name(), $order->customer()->email(), $order->preferredDeliveryDate());
        $reviewRequestSenderMock = $this->createMock(DummyReviewRequestSenderService::class);
        $reviewRequestSenderMock->method('send')
            ->willReturn($reviewRequest);

        $warehouseService = new WarehouseService(new DummyPicklistRepository(),
            $mailerServiceMock,
            $reviewRequestSenderMock,
            $this->customerRepositoryMock,
            $this->orderRepository,
            new DummyOrderFulfillmentService(),
            $this->shipmentRepository,
            $this->discountCodeRepository);

        // When
        $handleShipmentCreatedJob = new HandleShipmentCreatedJob($warehouseService, $shipment, $this->user->name);
        $useCaseResult = $handleShipmentCreatedJob->handle();

        // Then
        $shipment = $this->shipmentRepository->findOneByReference($shipment->reference());
        self::assertNotNull($shipment->trackAndTraceMailSent());
    }

    /** @test */
    public function it_should_not_send_track_and_trace_email()
    {
        // Given
        $order = OrderFactory::create(1, [
            'status' => 'unprocessed'
        ])->first();
        $this->orderRepository->add($order);

        $shipment = ShipmentFactory::create($order->reference(), [
            'trackAndTraceMailSent' => false
        ]);
        $shipment->changeOrderedItems(collect($order->items()));

        $mailerServiceMock = $this->createMock(DummyMailerService::class);
        $mailerServiceMock->method('isAlreadySent')
            ->willReturn(false);

        $reviewRequest = new ReviewRequest($order->reference(), $order->customer()->name(), $order->customer()->email(), $order->preferredDeliveryDate());
        $reviewRequestSenderMock = $this->createMock(DummyReviewRequestSenderService::class);
        $reviewRequestSenderMock->method('send')
            ->willReturn($reviewRequest);

        $warehouseService = new WarehouseService(new DummyPicklistRepository(),
            $mailerServiceMock,
            $reviewRequestSenderMock,
            $this->customerRepositoryMock,
            $this->orderRepository,
            new DummyOrderFulfillmentService(),
            $this->shipmentRepository,
            $this->discountCodeRepository);

        // When
        $handleShipmentCreatedJob = new HandleShipmentCreatedJob($warehouseService, $shipment, $this->user->name,false);
        $useCaseResult = $handleShipmentCreatedJob->handle();

        // Then
        $shipment = $this->shipmentRepository->findOneByReference($shipment->reference());
        self::assertNull($shipment);
    }

    /** @test */
    public function it_should_return_ok_and_push_job_to_queue()
    {
        $this->withoutExceptionHandling();
        Queue::fake();

        // Given
        $url = route('handle-warehouse-webhook', [
            'webhookName' => "picqer"
        ]);
        $this->app->bind(\App\PostNL\Classes\Carrier::class, DummyCarrier::class);
        $this->app->bind(ReviewRequestSenderServiceInterface::class, DummyReviewRequestSenderService::class);
        $orderReference = 'Test Order Reference';
        $shipment = ShipmentFactory::create($orderReference);
        $picqerShipmentRepositoryMock = $this->mock(DummyShipmentRepository::class, function (MockInterface $mock) use ($shipment) {
            $mock->shouldReceive('findOneByPicklistReference')->once()->andReturn($shipment);
        });

        $this->app->bind(ShipmentRepositoryInterface::class, function () use ($picqerShipmentRepositoryMock) {
            return $picqerShipmentRepositoryMock;
        });

        // When
        $response = $this->post($url, [
            "idhook" => 11252,
            "name" => "Zending aangemaakt",
            "event" => "picklists.shipments.created",
            "event_triggered_at" => "2022-03-28 15:37:19",
            "data" => [
                "idshipment" => 56457051,
                "idpicklist" => 58468546,
                "idorder" => 88846252,
                "idreturn" => null,
                "idshippingprovider" => 2,
                "idcompany_shippingprovider" => 7501,
                "idcompany_shippingprovider_profile" => 18846,
                "provider" => "PostNL",
                "providername" => "PostNL",
                "public_providername" => "PostNL",
                "profile_name" => "Standaard",
                "carrier_key" => "postnl",
                "labelurl" => "https://files-cdn.picqer.net/3994/eaec47a2-9986-420a-963d-a1e44433dc0d/label_3SDKTE1205115.pdf",
                "labelurl_pdf" => "https://files-cdn.picqer.net/3994/eaec47a2-9986-420a-963d-a1e44433dc0d/label_3SDKTE1205115.pdf",
                "labelurl_zpl" => null,
                "trackingcode" => "3SDKTE1205115",
                "trackingurl" => "https://postnl.nl/tracktrace/?B=3SDKTE1205115&P=12345AB&D=CZ&T=C",
                "tracktraceurl" => "https://postnl.nl/tracktrace/?B=3SDKTE1205115&P=12345AB&D=CZ&T=C",
                "created_by_iduser" => $this->employee->identity(),
                "cancelled" => false,
                "created" => "2022-03-28 15:37:19",
                "updated" => "2022-03-28 15:37:19",
            ]
        ]);

        // Then
        $response->assertOk();
        Queue::assertPushedOn('shipping', HandleShipmentCreatedJob::class);
    }

    /** @test */
    public function it_should_send_a_review_invite_when_order_is_fully_fulfilled()
    {
        // Given
        $order = OrderFactory::create(1, [
            'status' => 'unprocessed'
        ])->first();
        $reviewRequest = new ReviewRequest($order->reference(), $order->customer()->name(), $order->customer()->email(), $order->preferredDeliveryDate());
        $reviewRequestSenderMock = $this->createMock(ReviewRequestSenderServiceInterface::class);
        $reviewRequestSenderMock->method('send')
            ->willReturn($reviewRequest);

        $this->orderRepository->add($order);
        $shipment = ShipmentFactory::create($order->reference());
        $shipment->changeOrderedItems(collect($order->items()));

        $warehouseService = new WarehouseService(new DummyPicklistRepository(),
            $this->mailerService,
            $reviewRequestSenderMock,
            $this->customerRepositoryMock,
            $this->orderRepository,
            new DummyOrderFulfillmentService(),
            $this->shipmentRepository,
            $this->discountCodeRepository);

        // When
        $handleShipmentCreatedJob = new HandleShipmentCreatedJob($warehouseService, $shipment, $this->user->name);
        $useCaseResult = $handleShipmentCreatedJob->handle();

        // Then
        self::assertEquals($reviewRequest, $useCaseResult->reviewRequestSent());
    }

    /** @test */
    public function it_should_not_send_a_review_invite_when_order_is_not_fulfilled()
    {
        // Given
        $order = OrderFactory::create(1, [
            'status' => 'unprocessed'
        ])->first();
        $shippingDate = CarbonImmutable::createFromDate(2022, 1, 1);
        $validUntil = CarbonImmutable::createFromDate(2022, 1, 2);

        $order->items()[0]->changeShippingDateEstimation(new ShippingDateEstimation($shippingDate, $validUntil));
        $order->items()[1]->changeShippingDateEstimation(new ShippingDateEstimation($shippingDate, $validUntil));

        $this->orderRepository->add($order);
        $shipment = ShipmentFactory::create($order->reference());
        $shipment->changeOrderedItems(collect(array($order->items()[0])));

        $orderFulfillmentService = $this->mock(OrderFulfillmentServiceInterface::class, function (MockInterface $mock) {
            $mock->shouldReceive('isFulfilled')
                ->once()
                ->andReturn(false);
        });

        $reviewRequest = new ReviewRequest($order->reference(), $order->customer()->name(), $order->customer()->email(), $order->preferredDeliveryDate());
        $reviewRequestSenderMock = $this->createMock(ReviewRequestSenderServiceInterface::class);
        $reviewRequestSenderMock->method('send')
            ->willReturn($reviewRequest);

        $warehouseService = new WarehouseService(new DummyPicklistRepository(),
            $this->mailerService,
            $reviewRequestSenderMock,
            $this->customerRepositoryMock,
            $this->orderRepository,
            $orderFulfillmentService,
            $this->shipmentRepository,
            $this->discountCodeRepository);

        // When
        $handleShipmentCreatedJob = new HandleShipmentCreatedJob($warehouseService, $shipment, $this->user->name);
        $useCaseResult = $handleShipmentCreatedJob->handle();

        // Then
        self::assertNull($useCaseResult->reviewRequestSent());
    }

    /** @test */
    public function it_should_send_the_review_email_only_once()
    {
        // Given
        $order = OrderFactory::create(1, [
            'status' => 'unprocessed'
        ])->first();
        $reviewRequest = new ReviewRequest($order->reference(), $order->customer()->name(), $order->preferredDeliveryDate());
        $reviewRequestSenderMock = $this->createMock(ReviewRequestSenderServiceInterface::class);
        $reviewRequestSenderMock->method('send')
            ->willReturn($reviewRequest);

        $reviewRequestSenderMock->method('isSent')
            ->willReturn(true);


        $this->orderRepository->add($order);
        $shipment = ShipmentFactory::create($order->reference());
        $shipment->changeOrderedItems(collect($order->items()));

        $orderFulfillmentService = $this->mock(OrderFulfillmentServiceInterface::class, function (MockInterface $mock) {
            $mock->shouldReceive('isFulfilled')
                ->once()
                ->andReturn(false);
        });

        $warehouseService = new WarehouseService(new DummyPicklistRepository(),
            $this->mailerService,
            $reviewRequestSenderMock,
            $this->customerRepositoryMock,
            $this->orderRepository,
            $orderFulfillmentService,
            $this->shipmentRepository,
            $this->discountCodeRepository);

        // When
        $handleShipmentCreatedJob = new HandleShipmentCreatedJob($warehouseService, $shipment, $this->user->name);
        $useCaseResult = $handleShipmentCreatedJob->handle();

        // Then
        self::assertNull($useCaseResult->reviewRequestSent());
    }

    /** @test */
    public function it_should_be_able_to_call_a_non_webhook_route_and_push_job_to_queue()
    {
        // Given
        Queue::fake();
        Passport::actingAs(User::factory()->create());
        $this->withoutExceptionHandling();
        $order = OrderFactory::create(1)->first();
        $shipment = ShipmentFactory::create($order->reference());
        $this->orderRepository->add($order);
        $this->shipmentRepository->save($shipment);

        $url = route('handle-shipment-created');

        // When
        $response = $this->post($url, [
            'order_reference' => $order->reference(),
            'send_track_and_trace_mail' => true,
            'delivery_option_name' => 'Test Delivery Option Name',
            'carrier_name' => 'Test Carrier Name',
            'agent' => 'delight',
        ]);

        // Then
        $response->assertOk();
        Queue::assertPushed(HandleShipmentCreatedJob::class);
    }

    /** @test */
    public function it_should_send_a_coupon_email_when_order_contains_a_coupon()
    {
        // Given
        // Voeg product toe met naam Waardebon
        /** @var Order $order */
        $order = OrderFactory::create(1)->first();

        $product = ProductFactory::product(strtolower(config('warehouse.discountcode.coupon')), uniqid(), [
            'description' => 'Home Design Shops Waardebon Besteed deze bon bij je volgende bestelling op ons complete assortiment van A-merk woonproducten.<br/><strong>T.w.v. € 110,00</strong>'
        ]);

        $orderedItem = OrderedItemFactory::orderedItem(null, $product, 1, $order->reference());(1);
        $order->addOrderedItem($orderedItem);

        $reviewRequestSenderMock = $this->createMock(ReviewRequestSenderServiceInterface::class);

        $this->orderRepository->add($order);
        $shipment = ShipmentFactory::create($order->reference());
        $shipment->changeOrderedItems(collect($order->items()));

        $warehouseService = new WarehouseService(new DummyPicklistRepository(),
            $this->mailerService,
            $reviewRequestSenderMock,
            $this->customerRepositoryMock,
            $this->orderRepository,
            new DummyOrderFulfillmentService(),
            $this->shipmentRepository,
            $this->discountCodeRepository
        );

        // When
        $handleShipmentCreatedJob = new HandleShipmentCreatedJob($warehouseService, $shipment, $this->user->name);
        $useCaseResult = $handleShipmentCreatedJob->handle();

        /** @var CouponMail $sentCouponEmail */
        $sentCouponEmail = $useCaseResult->sentEmails()->filter(function($email) {
            return get_class($email) === CouponMail::class;
        })->first();

        $discountCodeInRepository = $this->discountCodeRepository->findOneByCode($sentCouponEmail->discountCode()->code());

        // Then
        self::assertNotNull($sentCouponEmail);
        self::assertNotNull($discountCodeInRepository);
        self::assertInstanceOf(DiscountCode::class, $sentCouponEmail->discountCode());
    }

    /** @test */
    public function it_should_not_send_a_coupon_email_when_the_order_already_generated_a_coupon()
    {
        // Given
        // Voeg product toe met naam Waardebon
        /** @var Order $order */
        $order = OrderFactory::create(1)->first();

        $product = ProductFactory::product(strtolower(config('warehouse.discountcode.coupon')), uniqid(), [
            'description' => 'Home Design Shops Waardebon Besteed deze bon bij je volgende bestelling op ons complete assortiment van A-merk woonproducten.<br/><strong>T.w.v. € 110,00</strong>'
        ]);

        $orderedItem = OrderedItemFactory::orderedItem(null, $product, 1, $order->reference());(1);
        $order->addOrderedItem($orderedItem);

        $reviewRequestSenderMock = $this->createMock(ReviewRequestSenderServiceInterface::class);

        $this->orderRepository->add($order);
        $shipment = ShipmentFactory::create($order->reference());
        $shipment->changeOrderedItems(collect($order->items()));

        $warehouseService = new WarehouseService(new DummyPicklistRepository(),
            $this->mailerService,
            $reviewRequestSenderMock,
            $this->customerRepositoryMock,
            $this->orderRepository,
            new DummyOrderFulfillmentService(),
            $this->shipmentRepository,
            $this->discountCodeRepository
        );

        // When
        $handleShipmentCreatedJob = new HandleShipmentCreatedJob($warehouseService, $shipment, $this->user->name);
        $useCaseResult = $handleShipmentCreatedJob->handle();

        /** @var CouponMail $sentCouponEmail */
        $sentCouponEmail = $useCaseResult->sentEmails()->filter(function($email) {
            return get_class($email) === CouponMail::class;
        })->first();

        $discountCodeInRepository = $this->discountCodeRepository->findOneByCode($sentCouponEmail->discountCode()->code());

        $secondUseCaseResult = $handleShipmentCreatedJob->handle();

        /** @var CouponMail $sentCouponEmail */
        $secondSentCouponEmail = $secondUseCaseResult->sentEmails()->filter(function($email) {
            return get_class($email) === CouponMail::class;
        })->first();

        // Then
        self::assertNull($secondSentCouponEmail);
        self::assertNotNull($sentCouponEmail);
        self::assertNotNull($discountCodeInRepository);
        self::assertInstanceOf(DiscountCode::class, $sentCouponEmail->discountCode());
    }
}
